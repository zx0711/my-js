<!--
 * @Description: call+apply+bind
 * @Author: xiao.zhang
 * @Date: 2020-12-28 14:55:00
 * @LastEditors: xiao.zhang
 * @LastEditTime: 2020-12-31 17:38:05
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /***
       * call、apply、bind
       * 每个函数对象都有call、apply、bind方法
       * 使用场景：改变this指向
       * call、apply、bind区别：call、apply是立即执行，bind是返回一个函数
       * 第一个参数：设置null/undefined,this指向当前执行环境的上下文
       */
      const dd = {
        name: 'zx',
        age: 19,
        getMoney: function () {
          // console.log('this', this)
        },
      }

      const newObj = {
        name: 'zxc',
      }

      dd.getMoney.call(null) //window
      dd.getMoney.call(newObj) //newObj
    </script>

    <script>
      /**
       * 手写call
       */
      Function.prototype.call1 = function (context, ...arr) {
        if (context === null || context === undefined) {
          // 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window)
          context = window
        } else {
          context = Object(context) // 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象
        }
        const specialPrototype = Symbol('特殊属性Symbol') // 用于临时储存函数
        context[specialPrototype] = this // 函数的this指向隐式绑定到context上
        let result = context[specialPrototype](...arr) // 通过隐式绑定执行函数并传递参数
        delete context[specialPrototype] // 删除上下文对象的属性
        return result // 返回函数执行结果
      }

      function test() {
        console.log(this)
      }
      // test()
      test.call1({ name: 1122 })
    </script>
  </body>
</html>
