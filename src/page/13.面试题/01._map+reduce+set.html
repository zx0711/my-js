<!--
 * @Description: 
 * @Author: xiao.zhang
 * @Date: 2020-12-28 10:46:16
 * @LastEditors: xiao.zhang
 * @LastEditTime: 2020-12-29 14:58:45
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /*
       * map函数
       * 接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回
       */
    </script>
    <script>
      /*
       * reduce函数
       * 为数组中的每一个元素依次执行回调函数
       * arr.reduce(callback,[initialValue])
       * callback函数可用四个参数
       * 1. previousValue(上一次调用回调函数返回的值，或者是初始值initialValue)
       * 2. currentValue(数组中当前被处理的元素)
       * 3. index(数组中当前被处理的元素的索引值)
       * 4. array(调用reduce的数组)
       */

      let arr1 = [2, 40, -10, 6]
      let result = arr1.reduce((a, b, index, array) => {
        console.log('上一次处理后：' + a)
        console.log('当前正在处理：' + b)
        console.log(index, array)
        return a + b
      }, 100)
      console.log('结果', result)
    </script>

    <script>
      /*
       * set属性和方法
       * set方法没有重复元素
       * set实例的属性和方法，比如获取长度: 实例对象.size
       */
      const set1 = new Set([1, 2, 3, 4, 4, 3, 5, 5])
      console.log('====set1===', [...set1]) //[1,2,3,4,5], set方法可以去重，没有重复元素
    </script>

    <script>
      const ff = [
        { key: '2', value: 2, total: NaN, ratio: NaN },
        { key: '5', value: 1, total: NaN, ratio: NaN },
        { key: '3', value: 2, total: NaN, ratio: NaN },
        { key: '4', value: 2, total: NaN, ratio: NaN },
        { key: '其他', value: 3, total: NaN, ratio: NaN },
        { key: '1', value: 1, total: NaN, ratio: NaN },
      ]
      const ddf = ff.reduce((a, b, index) => {
        return a + b.value
      }, 0)
      console.log('ff', ddf)
    </script>
  </body>
</html>
