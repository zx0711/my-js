<!--
 * @Description: 对象创建的5种模式
 * @Author: xiao.zhang
 * @Date: 2020-12-09 16:15:02
 * @LastEditors: xiao.zhang
 * @LastEditTime: 2020-12-09 17:23:45
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /*
       * 1.Object构造函数模式
       * 套路: 先创建空Object对象, 再动态添加属性/方法
       * 适用场景: 起始时不确定对象内部数据
       * 问题: 语句太多
       */
      var person = new Object()

      person.name = 'name'
      person.age = 43

      console.log(person)
    </script>

    <script>
      /*
       * 2.对象字面量
       * 套路: 使用{}创建对象, 同时指定属性/方法
       * 适用场景: 起始时不确定对象内部数据
       * 问题: 语句太多
       */
      var person1 = {
        name: 'person1',
        age: 41,
      }

      var person2 = {
        name: 'person2',
        age: 2,
      }
    </script>

    <script>
      /*
       * 3.工厂模式
       * 套路: 通过工厂函数动态创建对象并返回（特点：每次都有return一个新的对象）
       * 适用场景: 需要创建多个对象
       * 问题: 对象没有一个具体的类型, 都是Object类型
       */
      function Person(name, age) {
        return {
          name: name,
          age: age,
        }
      }

      var person1 = Person('person1', 4)
      var person2 = Person('person2', 5)
    </script>

    <script>
      /*
       * 4.自定义构造函数模式
       * 套路: 自定义构造函数, 通过new创建对象
       * 适用场景: 需要创建多个类型确定的对象
       * 问题: 每个对象都有相同的数据, 浪费内存
       */
      function Person(name, age) {
        this.name = name
        this.age = age
      }

      var person1 = new Person('person1', 55)
    </script>

    <script>
      /*
       * 4.构造函数加原型的组合模式
       * 套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上
       * 适用场景: 需要创建多个类型确定的对象
       * 问题: 没有问题
       */
      function Person(name, age) {
        this.name = name
        this.age = age
      }

      Person.prototype.eat = function () {
        console.log('person eat')
      }

      var person1 = new Person('person1', 55)

      person1.eat()
    </script>
  </body>
</html>
